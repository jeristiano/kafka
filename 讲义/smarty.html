
<!DOCTYPE html>
<html>
<head>
<title>smarty</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: "΢���ź�"��Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #000;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>Smarty</h1>

<h2>Smaty是什么?</h2>

<p>Smarty是一个php模板引擎。更准确的说,它分开了逻辑程序和外在的内容,提供了一种易于管理的方法。可以描述为应用程序员和美工扮演了不同的角色，因为在大多数情况下，他们不可能是同一个人。</p>

<p><strong>例如，你正在创建一个用于浏览新闻的网页。</strong></p>

<ul>
<li>新闻标题、标签栏、作者和内容等变量都是内容要素，他们并不包含应该怎样呈现的信息。而这些正是Smarty要做的。</li>
<li>模板设计者们编辑模板,组合使用html标签和模板标签去格式化这些要素的输出(html表格,背- 景色,字体大小,样式表,等等)。 </li>
<li>有一天程序员想要改变文章检索的方式(也就是程序逻辑的改变)。这个改变不影响模板设计者,内容仍将准确的输出到模板。</li>
<li>同样的,哪天美工吃多了想要完全重做界面,也不会影响到程序逻辑。</li>
<li>因此,程序员可以改变逻辑而不需要重新构建模板,模板设计者可以改变模板而不影响到逻辑。 </li>
</ul>

<p><strong>Smarty总的设计理念就是分离业务逻辑和表现逻辑。</strong></p>

<ul>
<li>这意味着模版在只为表现外在内容而存在的前提下必定包含逻辑。</li>
<li>诸如载入其它模版、交替显示表格行颜色、大写变量、循环数据数组并将其显示出来，此谓模版的表现逻辑的例子。 </li>
<li>但这并不意味着Smarty强制分离业务逻辑和表现逻辑。Smarty不具备分清谁是谁的能力，因此只要你高兴，你照样可以将业务逻辑放入模版。 </li>
<li>此外，如果你希望在模版中不包含逻辑，你当然可以只将内容加工为文本和变量。 </li>
</ul>

<p><strong>Smaty的一些特点:</strong> </p>

<ul>
<li>非常非常的快! </li>
<li>用php分析器干这个苦差事是有效的</li>
<li>不需要多余的模板语法解析,仅仅是编译一次 </li>
<li>仅对修改过的模板文件进行重新编译 </li>
<li>可以编辑'自定义函数'和自定义'变量',因此这种模板语言完全可以扩展 </li>
<li>可以自行设置模板定界符,所以你可以使用<code>{}, {{}}, &lt;!--{}--&gt;</code>, 等等 </li>
<li>诸如 <code>{if}{elseif}{else}{endif}</code> 结构可以被传递到php语法解析器,所以 <code>{if ...}</code> 表达式是简单的或者是复杂的,随你喜欢啦 </li>
<li>可以无限嵌套<code>sections、if</code>等。 </li>
<li>内置缓存支持 </li>
<li>独立模板文件 </li>
<li>可自定义缓存处理函数 </li>
<li>模板继承易于管理模板内容 </li>
<li>插件体系结构</li>
</ul>

<h2>要求</h2>

<p>Smarty要求web服务器运行php5.2以上版本. </p>

<h2>基本安装</h2>

<p>安装Smarty很简单，只须将Smarty库文件放在/libs/目录里就行了(就是解压了)， 你可不能修改这些php文件哦。这些文件被所有应用程序共享，也只能在你升级到新版的smarty的时候得到更新。</p>

<ul>
<li>Smarty要求4个目录,默认下命名为:tempalates, templates_c, configs and cache。 </li>
<li>每个都是可以自定义的,可以分别修改Smarty类属性: $template<em>dir, $compile</em>dir, $config<em>dir和$cache</em>dir。 </li>
<li>强烈推荐你为每个用到smarty的应用程序设置单一的目录（如同Smarty安装包里的demo的文件结构）! </li>
</ul>

<h2>Smarty 缺点</h2>

<ul>
<li>中小型的项目不适合</li>
<li>实时更新数据的网站中不适用</li>
<li>第一次运行的时候 编译需要时间   </li>
</ul>

<h2>使用smarty</h2>

<pre><code>require './smarty/Autoloader.php';
Smarty_Autoloader::registerBC();
$smarty = new SmartyBC();

$smarty-&gt;template_dir = "./Tpl";   //配置模版目录
$smarty-&gt;compile_dir  = "./comp";  //配置编译目录,编译文件: 通过模板引擎将模板生成的php+html的混合写
$smarty-&gt;cache_dir    = "./cache"; //配置缓存目录,缓存文件: 通过模板引擎将模板生成的纯的HTML文件
$smarty-&gt;config_dir   = "./conf";  //配置前台样式配置文件的目录  
smarty-&gt;left_delimiter = "{";     //配置模版标签的左边界符
$smarty-&gt;right_delimiter= "}";     //配置模版标签的右边界符
$smarty-&gt;caching        = true/false;   //是否开启缓存
$smarty-&gt;cache_lifetime = 10;    //缓存的有效时间  单位: S
</code></pre>

<p><strong>注意：</strong>这里将以秒为单位进行计算缓存有效的时间。第一次缓存时间到期时,当Smarty的caching变量设置为true时缓存将被重建。当它的取值为-1时表示建立起的缓存从不过期，为0时表示在程序每次执行时缓存总是被重新建立。</p>

<h2>Smarty类方法</h2>

<h3>从PHP分配的变量</h3>

<pre><code>$smarty-&gt;assign('firstname', 'Doug');
$smarty-&gt;assign('lastname', 'Evans');
$smarty-&gt;assign('meetingPlace', 'New York');
</code></pre>

<h3>显示模板</h3>

<pre><code>$smarty-&gt;display(模版文件);
</code></pre>

<h3>模板注释</h3>

<pre><code>{* 我是Smarty 注释, 在编译输出后我并不存在 *}
</code></pre>

<h2>变量</h2>

<p>数学和嵌入标签:</p>

<pre><code>{$x+$y}                             // 输出x+y的和.
{assign var=foo value=$x+$y}        // 属性中的变量 
{$foo[$x+3]}                        // 变量作为数组索引
{$foo={counter}+3}                  // 标签里面嵌套标签
{$foo="this is message {counter}"}  // 引号里面使用标签
</code></pre>

<p>定义数组:</p>

<pre><code>{assign var=foo value=[1,2,3]}
{assign var=foo value=['y'=&gt;'yellow','b'=&gt;'blue']}
{assign var=foo value=[1,[9,8],3]}   // 可以嵌套
</code></pre>

<p>短变量分配:</p>

<pre><code>{$foo=$bar+2}
{$foo = strlen($bar)}               // 带参函数
{$foo = myfunct( ($x+$y)*3 )}       // 作为函数参数 {$foo.bar=1}                        // 赋值给指定的数组索引{$foo.bar.baz=1}                    
{$foo[]=1}                          // 数组添加一个值
</code></pre>

<p>Smarty "dot" 语法 (注意: 嵌入的{}用来解决指代不明的情况):</p>

<pre><code>{$foo.a.b.c}      相当于  $foo['a']['b']['c'] 
{$foo.a.$b.c}     相当于  $foo['a'][$b]['c']         // 带变量下标
{$foo.a.{$b+4}.c} 相当于  $foo['a'][$b+4]['c']       // 表达式作为索引
{$foo.a.{$b.c}}   相当于  $foo['a'][$b['c']]         // 嵌套索引
</code></pre>

<p>PHP式语法, "dot"语法外的另一种选择:</p>

<pre><code>{$foo[1]}             // normal access
{$foo['bar']}{$foo['bar'][1]}
{$foo[$x+$x]}         // 下标可带任何表达式
{$foo[$bar[1]]}       // 嵌套下标
{$foo[section_name]}  // 访问Smarty节块变量{section}，而非访问数组
</code></pre>

<p>可变变量:</p>

<pre><code>$foo                     // 普通变量
$foo_{$bar}              // 变量名包含其它变量
$foo_{$x+$y}             // 变量名包含表达式
$foo_{$bar}_buh_{$blar}  // 多段变量名
{$foo_{$x}}              // 输出变量 $foo_1 ，如果 $x 的值为1 。
</code></pre>

<p>请求变量：</p>

<p>请求变量诸如<code>$_GET, $_POST,$_COOKIE, $_SERVER, $_ENV and $_SESSION</code> 下面举例说明他们的用法:</p>

<pre><code>显示请求变量 
{* 显示URL ($_GET) http://www.example.com/index.php?page=fo页面里的值 *}{$smarty.get.page}
{*  显示($_POST['page'])的"page"值 *}
{$smarty.post.page}
{* 显示cookie "username" ($_COOKIE['username'])的值 *}
{$smarty.cookies.username}
{* 显示服务器变量 "SERVER_NAME" ($_SERVER['SERVER_NAME'])*}
{$smarty.server.SERVER_NAME}{* 显示系统变量 "PATH" *}
$smarty.env.PATH}
{* 显示php的session变量 "id" ($_SESSION['id']) *}
{$smarty.session.id}
{* 显示联合了get/post/cookies/server/env的变量 "username"  *}
{$smarty.request.username}
</code></pre>

<p>直接使用php函数:</p>

<pre><code>{time()} //译注：如果直接使用模版变量符号引用php函数，该函数应有返回值。
</code></pre>

<h2>变量调节器</h2>

<p>前面我们学习了怎么在smarty模版中使用变量，但有些时候，在模版中我们不仅需要的是变量的值，有时候还要对变量进行一定的修饰。 （这个过程其实等同于我们php中的字符串函数对字符串的修饰）</p>

<ul>
<li>格式 <code>{$变量|函数名:参1:参2|函数2:参1:参2|......}</code></li>
</ul>

<p><strong>注意:</strong>变量与后面的修饰函数之间以竖线隔开，修饰函数则用冒号设置参数，参数之间也是冒号，而多个函数之间也是用竖线来隔开，这样可以做到连续操作（函数嵌套）</p>

<ul>
<li><p>capitalize:将字符串中的每个单词的首字母大写</p>

<pre><code>&lt;?php
    $smarty-&gt;assign('articleTitle', 'next x-men film, x3, delayed.');
?&gt; 
</code></pre>

<p>模板:</p>

<pre><code>{$articleTitle}
{$articleTitle|capitalize}
{$articleTitle|capitalize:true}   
</code></pre>

<p>输出:
    next x-men film, x3, delayed.
    Next X-Men Film, x3, Delayed.
    Next X-Men Film, X3, Delayed.</p></li>
<li><p>count_characters:ture/false  :统计字符个数,true计算空格，false忽略空格；默认值为false忽略空格</p>

<pre><code>&lt;?php
    $smarty-&gt;assign('articleTitle', 'Cold Wave Linked to Temperatures.');
?&gt;
</code></pre>

<p>模板:</p>

<pre><code>{$articleTitle}
{$articleTitle|count_characters}
{$articleTitle|count_characters:true}
</code></pre>

<p>输出:</p>

<pre><code>Cold Wave Linked to Temperatures.
29
33 
</code></pre></li>
<li><p>cat:”xxx”  :将xxx连接到字符串后面  concat</p>

<pre><code>&lt;?php
    $smarty-&gt;assign('articleTitle', "Psychics predict world didn't end");
?&gt;
</code></pre>

<p>index.tpl:</p>

<pre><code>{$articleTitle|cat:" yesterday."}
</code></pre>

<p>输出:</p>

<pre><code>Psychics predict world didn't end yesterday.
</code></pre></li>
<li><p>date_format:”%Y-%m-%d”    设置日期格式  date(“Y-m-d”)</p>

<p>{$smarty.now|date_format:"%Y-%m-%d"}</p></li>
<li><p>Default:”默认值”     当变量值为空时，将使用default后面值</p></li>
<li>lower:            将字符转换为小写</li>
<li>upper:       将字符转换为大写</li>
<li>indent:   缩进    {$str|indent:10:"&amp;nbsp"}<br />
    <strong>注意</strong>，在模版中要使用“&amp;nbsp”来替换缩进内容
        strip_tags:去掉HTML标签 
        replace:”val1”:”val2”   字符串替换    用 $val2来替换$val1</li>
<li>truncate: 截取字符串  ，三个参数都可省   substr($str,$start,$length)
<ul>
<li>参数1：  截取的字符串长度 ，默认截取80个字节</li>
<li>参数2：    被截取出的字符串后连接的字符  默认...      ...是计算到长度</li>
<li>参数3：    true|false    默认为false，指的是截取到词的边界（不会断词）true则表示截取精确的字节数  </li>
</ul></li>
</ul>

<h2>内置模版标签</h2>

<h3>{literal}</h3>

<p><code>{literal}</code>标签区域内的数据将按字面意思处理，代表性地是用在javascript/css语块周围，不然这些语言使用的花括号‘{’、‘}’会干扰模版定界符语法。</p>

<p><code>{literal}{/literal}</code>标签里面的所有符号不会被解释，全部按原样输出。如果有需要在{literal}块里使用模版标签，可以考虑使用{ldelim}{rdelim}转义单独的分隔符。</p>

<pre><code>&lt;script&gt;   
    // 下面的花括号会被Smarty忽略解析   
    // 因为它们被空格符包围   
    function myFoo {     alert('Foo!');   }   // 下面这种情况须用{literal}转义   
    {literal}     
        function myBar {alert('Bar!');}   
    {/literal}
&lt;/script&gt;
</code></pre>

<h3>控制结构标签</h3>

<p><strong>{if}{elseif}{else} 条件</strong></p>

<pre><code>{if isset($name) &amp;&amp; $name == 'Blog'}
    {* 内容处理 *}
{elseif $name == $foo}
    {* 内容处理 *}
{/if}

{if is_array($foo) &amp;&amp; count($foo) &gt; 0}    
    {* foreach循环 *}
{/if}
</code></pre>

<p>比较运算符替换词</p>

<pre><code> &gt;    gt
 &lt;    lt
 ==   eq
 !=   neq
 &gt;=   gte
 &lt;=   lte
</code></pre>

<p><strong>注意：</strong> 替换的单词左右必须有空格</p>

<p><strong>{for} 循环</strong></p>

<ul>
<li><p>简单的{for}循环 </p>

<pre><code>&lt;ul&gt;
    {for $foo=1 to 3}    
        &lt;li&gt;{$foo}&lt;/li&gt;
    {/for}
&lt;/ul&gt;  
</code></pre>

<p>上例输出：</p>

<pre><code>&lt;ul&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
&lt;/ul&gt;
</code></pre></li>
<li><p>使用最大属性</p>

<pre><code>&lt;?php$smarty-&gt;assign('to',10);?&gt;
&lt;ul&gt;
    {for $foo=3 to $to max=3}
        &lt;li&gt;{$foo}&lt;/li&gt;
    {/for}
&lt;/ul&gt;  
</code></pre>

<p>上例输出：</p>

<pre><code>&lt;ul&gt;
    &lt;li&gt;3&lt;/li&gt;
    &lt;li&gt;4&lt;/li&gt;
    &lt;li&gt;5&lt;/li&gt;
&lt;/ul&gt;
</code></pre></li>
<li><p>执行{forelse}</p>

<pre><code>$smarty-&gt;assign('start',10);
$smarty-&gt;assign('to',5);  
&lt;ul&gt;
    {for $foo=$start to $to}
        &lt;li&gt;{$foo}&lt;/li&gt;
    {forelse}
        no iteration
    {/for}
&lt;/ul&gt; 
</code></pre>

<p>上例输出：  </p>

<pre><code>no iteration
</code></pre></li>
</ul>

<p><strong>{foreach},{foreachelse}遍历</strong></p>

<pre><code>&lt;?php
    $arr = array('red', 'green', 'blue');
    $smarty-&gt;assign('myColors', $arr);
?&gt;  
</code></pre>

<p>模板在无序li中输出$myColors</p>

<pre><code>&lt;ul&gt;
    {foreach $myColors as $color}
        &lt;li&gt;{$color}&lt;/li&gt;
    {/foreach}
&lt;/ul&gt;  
</code></pre>

<p>上例输出：</p>

<pre><code>&lt;ul&gt;    
    &lt;li&gt;red&lt;/li&gt;
    &lt;li&gt;green&lt;/li&gt;
    &lt;li&gt;blue&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p><strong>{section},{sectionelse}遍历数组</strong></p>

<p>{foreach}可以做{section}能做的所有事，而且语法更简单、更容易。它通常是循环数组的首选。</p>

<h2>引入其他模版</h2>

<p><strong>{include}</strong> </p>

<p>{include}标签用于在当前模板中包含其它模板。当前模板中的任何有效变量在被包含模板中同样可用。 </p>

<p><strong>一个简单的{include}演示</strong> </p>

<pre><code>&lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;{$title}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        {* 必须指定file属性，该属性指明模板资源的位置 *}
        {include file='page_header.tpl'}
        {* 模板的body, $tpl_name变量用一个诸如'contact.tpl'的值来代替 *}
        {include file="$tpl_name.tpl"}
        {* 使用文件简写形式的特性 *}
        {include 'page_footer.tpl'}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><strong>带传递参数的{include}演示</strong></p>

<pre><code>{include 'links.tpl' title='Newest links' links=$link_array}
{* 模板的body *}
{include 'footer.tpl' foo='bar'}  
</code></pre>

<p>上述模板包含的links.tpl例子如下：</p>

<pre><code>&lt;div id="box"&gt;
    &lt;h3&gt;{$title}{/h3&gt;
    &lt;ul&gt;
        {foreach from=$links item=l}
            .. 这里进行填充  ...
        {/foreach}
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>

<p><strong>从配置文件引用的变量</strong></p>

<p>config file - foo.conf:</p>

<pre><code>pageTitle = "This is mine"
bodyBgColor = '#eeeeee'
tableBorderSize = 3
tableBgColor = "#bbbbbb"
rowBgColor = "#cccccc"
</code></pre>

<p>下面为配置文件变量#hash#方法的示例:</p>

<pre><code>{config_load file='foo.conf'}
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;{#pageTitle#}&lt;/title&gt;
    &lt;/head&gt;     
    &lt;body bgcolor="{#bodyBgColor#}"&gt;
        &lt;table border="{#tableBorderSize#}" bgcolor="{#tableBgColor#}"&gt;
            &lt;tr bgcolor="{#rowBgColor#}"&gt;
                &lt;td&gt;First&lt;/td&gt;
                &lt;td&gt;Last&lt;/td&gt;
                &lt;td&gt;Address&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>下面为$smarty.config方法的示例：</p>

<pre><code>{config_load file='foo.conf'}
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;{$smarty.config.pageTitle}&lt;/title&gt;
    &lt;/head&gt; 
    &lt;body bgcolor="{$smarty.config.bodyBgColor}"&gt;
        &lt;table border="{$smarty.config.tableBorderSize}" bgcolor="{$smarty.config.tableBgColor"}&gt;
            &lt;tr bgcolor="{$smarty.config.rowBgColor}"&gt;
                &lt;td&gt;First&lt;/td&gt;
                &lt;td&gt;Last&lt;/td&gt;
                &lt;td&gt;Address&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h1>smarty插件</h1>

<p>插件:  就是smarty中能够完成一定功能的函数，插件目录  <code>/smarty/plugins/</code></p>

<h2>smarty系统的插件</h2>

<p><strong>{html_options}</strong></p>

<p>自定义函数{html_options}根据给定的数据创建<code>&lt;select&gt;&lt;option&gt;</code>选项组。它会留意哪个选项在默认情况下被选中</p>

<p><strong>{html_checkboxes}</strong></p>

<p>自定义函数{html_checkboxes}根据给定的数据创建复选按钮组。该函数可以指定哪些元素被选定。</p>

<p><strong>{html_radios}</strong></p>

<p>自定义函数{html_radios}根据给定的数据创建html单选按钮组，该函数可以指定哪个元素被选定。 </p>

<p><strong>{html_table}</strong></p>

<p>自定义函数{html_table}将数组中的数据填充到HTML表格中。</p>

<h2>通过插件扩展Smarty</h2>

<h3>命名约定</h3>

<p>插件文件和函数必须遵循特定的命名约定以便Smarty识别。 </p>

<p>插件文件必须命名如下：</p>

<p><code>type.name.php</code> </p>

<p>其中type为下面这些插件类型中的一种： </p>

<pre><code>function 
modifier 
block 
compiler 
prefilter 
postfilter 
outputfilter 
resource 
insert 
</code></pre>

<p>name为合法标识符，仅包含字母、数字和下划线。举例如下：<code>function.html_select_date.php, resource.db.php, modifier.spacify.php</code>。 </p>

<h3>模板函数</h3>

<pre><code>void smarty_function_name($params, $smarty);
array $params;
object $smarty;
</code></pre>

<ul>
<li>模板传递给模板函数的所有属性都包含在关联数组$params中。 </li>
<li>在模板中，函数的输出内容（返回值）在原位置用函数标签代替，例如{fetch}函数。作为另一种选择，函数也可以单纯地用来做些非输出内容的任务，如{assign}函数。</li>
<li><p>如果函数需要分配（俗话说的赋值）一些变量给模板或者使用Smarty提供的一些函数，可以通过$smarty对象实现，如$smarty->foo()。</p>

<p>例： </p>

<pre><code>&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     function.eightball.php
 * Type:     function
 * Name:     eightball
 * Purpose:  outputs a random magic answer
 * -------------------------------------------------------------
 */
function smarty_function_eightball($params, $smarty)
{
    $answers = array('Yes',
                     'No',
                     'No way',
                     'Outlook not so good',
                     'Ask again soon',
                     'Maybe in your reality');
    $result = array_rand($answers);
    return $answers[$result];
}
?&gt;
模板中这样使用:
Question: Will we ever have time travel?
Answer: {eightball}. 
</code></pre></li>
</ul>

<h3>变量调节器</h3>

<p>调节器是一些简短的函数，这些函数被应用于显示模板前作用于一个变量，或者其它情形中。调节器可以连接起来（执行）。 </p>

<pre><code>mixed smarty_modifier_name($value, $param1);
mixed $value;
[mixed $param1, ...];
</code></pre>

<ul>
<li>调节器插件的第一个参数应该直接了当地声明处理什么类型（可以是字符串、数组、对象等等这些类型）。其它的参数是可选的，取决于执行的操作类型。</li>
<li><p>调节器必须返回处理结果。</p>

<p>例：</p>

<pre><code>&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     modifier.capitalize.php
 * Type:     modifier
 * Name:     capitalize
 * Purpose:  capitalize words in the string
 * -------------------------------------------------------------
 */
function smarty_modifier_capitalize($string)
{
    return ucwords($string);
}
?&gt;
</code></pre></li>
</ul>

<h1>缓存</h1>

<p>大家应该知道缓存机制能能有效的减轻网站的服务器压力，Smarty模板引擎的一大亮点就是为我们提供了非常简单的缓存操作，下面就让我们学习一下。</p>

<p>首先我们要知道Smarty缓存机制分为全局缓存，部分缓存，局部缓存三种，我们一一介绍。</p>

<h2>全局缓存</h2>

<p>顾名思义，全局缓存就是为整个网站的全部页面都生成缓存页面。</p>

<p>首先我们要操作smarty的配置文件，开启缓存，指定缓存文件目录，并设置缓存的存活时间</p>

<pre><code>$smarty-&gt;cache_dir = ‘./cache/’;      //设置存放缓存文件的文件夹
$smarty-&gt;caching = 1;            //开启缓存 0、FALSE代表关闭|非0数字、TRUE代表开启
$smarty-&gt;cache_lifetime = 3600         //单位为秒(如果填写-1为永不过期)
</code></pre>

<p>接下来我们要去具体的php页面设置与之对应的具体缓存文件的名字</p>

<pre><code>$smarty-&gt;display(‘list2.html’,$cache_id);//设置缓存文件名
</code></pre>

<p>需要注意的是：</p>

<pre><code>    $smarty-&gt;display(‘与之对应的模板文件名’,'缓存文件名的补充部分’)
</code></pre>

<p>这个方法的第二个参数不是必须的，如果不写的话，缓存文件名就是过加密处理的模板文件名。但是这样会碰到一个比较棘手的问题：</p>

<pre><code>    http://localhost/1.10/sm/list2.php?lan=1
    http://localhost/1.10/sm/list2.php?lan=2
    http://localhost/1.10/sm/list2.php?lan=3    

    3个URL对应应该的不同的内容，但是生成的缓存文件名都是list2.html加密后的结果。
</code></pre>

<p>这就会导致用户想要查询的是不同的内容，访问的却是同一个缓存文件。</p>

<p>所以建议加上一个辅助参数，将访问url(包含?后面的所有参数)md5加密。</p>

<pre><code>    $file = $_SERVER[“REQUEST_URI”],取其文件名加密
            结果： E://www/20160217/oop/o2/index.php?id=1

    $result = Basename($file)  // 取基本文件名和传值信息
            结果: index.php?id=2

    $cache_id = Md5($result)
            $cache_id 指的是对模版文件名以及其传值md5得到的字符串
</code></pre>

<p>这样就可以得到带有不同传值的加密缓存文件了。比如：</p>

<pre><code>04e62887936edf3e6b7a92895ccb8ba^we221asd21wasd2335dAS2.news.tpl.php
</code></pre>

<h2>部分缓存</h2>

<p>部分缓存，其实就是指定一些文件生成缓存文件，而非网站的全部文件。实时刷新数据的页面就无需缓存，了解了需要达到的效果，接下来我们就来具体操作，操作之前，我们先要强调一个概念：</p>

<p><strong>部分缓存的实质其实是部分不缓存，也就是说不是指定哪些文件生成缓存，而是指定具体一些文件不生成缓存</strong></p>

<p>实现方法：
假设有3个文件：</p>

<pre><code>1.html //需要缓存
2.html //需要缓存
3.html //不需要缓存
</code></pre>

<ol>
<li>在1.html和2.html文件中还是照旧写上$smarty->display(‘与之对应的模板文件名’,’缓存文件名的补充部分’)这个方法。</li>
<li>但在3.html中我们要特别指明不需要生成缓存，具体的方法是：$smarty->clear_cache(‘与之对应的模板文件名’)，写在$smarty->display(‘与之对应的模板文件名’) 的后面</li>
<li>当然$smarty->display(‘与之对应的模板文件名’)还是要写，本来就不想生成缓存，第二个参数也就不需要了。</li>
<li>$smarty->clear_cache()和$smarty->display()的参数一定要写成一致的</li>
</ol>

<h2>局部缓存</h2>

<p>首先让我们了解下局部缓存的意思，就是指定同一页面下的某些局部地方生成缓存。同样的在这里我们也要把思路反转一下。其实不是指定哪些局部生成缓存，而是哪些局部不生成缓存(这和部分缓存的操作思想是类似的)。</p>

<p>话不多说，先举一个实例</p>

<p>php部分</p>

<pre><code>$time=time();
$smarty-&gt;assign(‘time’,$time);

$smarty-&gt;display(’1.html’)
</code></pre>

<p>插件部分</p>

<pre><code>insert.gettime.php//插件文件名称

function smarty_insert_gettime()
{
    return time();
}
</code></pre>

<p>模版部分</p>

<pre><code>{$time}
    //开启缓存后，重复刷新这个不会变
{insert name=gettime}
    //开启缓存后，重复刷新这个会变
</code></pre>

<p><strong>函数名为insert_自定义补充名的自定义函数，在其中返回的值，不需要assign()方法传递，就能直接在模板页面中以{insert name=’自定义补充名’}的方式调用，同时不会受到缓存的影响，而实时刷新</strong></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
